# generated by fastapi-codegen:
#   filename:  openapi.json

from __future__ import annotations

from fastapi import APIRouter, HTTPException
from uuid import uuid4
from typing import Union, Dict, Any, Optional, Annotated, TYPE_CHECKING
from uuid import UUID, uuid4
from pydantic import BaseModel, Field
from enum import Enum
from datetime import datetime
import pytz
from models import IfExists, Status1

from models import (
    Any,
    ErrorResponse,
    Optional,
    Thread,
    ThreadCreate,
    ThreadPatch,
    ThreadSearchRequest,
    ThreadState,
    ThreadStateUpdate,
    ThreadStateUpdateResponse,
    ThreadsSearchPostResponse,
    ThreadsThreadIdHistoryGetResponse,
    UUID,
    Union,
)

router = APIRouter(tags=["Threads"])
threads_db = {}

@router.post(
    "/threads",
    response_model=Thread,
    responses={"409": {"model": ErrorResponse}, "422": {"model": ErrorResponse}},
    tags=["Threads"],
)
def create_thread_threads_post(body: ThreadCreate) -> Union[Thread, ErrorResponse]:
    """
    Create Thread
    """
    # Generate thread_id if not provided
    thread_id = body.thread_id if body.thread_id else uuid4()
    
    # Check if thread already exists
    if str(thread_id) in threads_db:
        if body.if_exists == IfExists.raise_:
            raise HTTPException(
                status_code=409,
                detail=f"Thread with ID {thread_id} already exists"
            )
        elif body.if_exists == IfExists.do_nothing:
            return threads_db[str(thread_id)]
    
    # Get current time with timezone
    current_time = datetime.now(pytz.UTC)
    
    # Create new thread
    new_thread = Thread(
        thread_id=thread_id,
        created_at=current_time,
        updated_at=current_time,
        metadata=body.metadata or {},
        status=Status1.idle,  # Default status for new threads is 'idle'
        values=None  # Initial values are None
    )
    
    # Store thread in database
    threads_db[str(thread_id)] = new_thread
    
    return new_thread



@router.post(
    "/threads/search",
    response_model=ThreadsSearchPostResponse,
    responses={"422": {"model": ErrorResponse}},
    tags=["Threads"],
)
def search_threads_threads_search_post(
    body: ThreadSearchRequest,
) -> Union[ThreadsSearchPostResponse, ErrorResponse]:
    """
    Search Threads
    """
    pass


@router.get(
    "/threads/{thread_id}",
    response_model=Thread,
    responses={"404": {"model": ErrorResponse}, "422": {"model": ErrorResponse}},
    tags=["Threads"],
)
def get_thread_threads__thread_id__get(thread_id: UUID) -> Union[Thread, ErrorResponse]:
    """
    Get Thread
    """
    pass


@router.delete(
    "/threads/{thread_id}",
    response_model=Any,
    responses={"404": {"model": ErrorResponse}, "422": {"model": ErrorResponse}},
    tags=["Threads"],
)
def delete_thread_threads__thread_id__delete(
    thread_id: UUID,
) -> Union[Any, ErrorResponse]:
    """
    Delete Thread
    """
    pass


@router.patch(
    "/threads/{thread_id}",
    response_model=Thread,
    responses={"404": {"model": ErrorResponse}, "422": {"model": ErrorResponse}},
    tags=["Threads"],
)
def patch_thread_threads__thread_id__patch(
    thread_id: UUID, body: ThreadPatch = ...
) -> Union[Thread, ErrorResponse]:
    """
    Patch Thread
    """
    pass


@router.post(
    "/threads/{thread_id}/copy",
    response_model=Thread,
    responses={"409": {"model": ErrorResponse}, "422": {"model": ErrorResponse}},
    tags=["Threads"],
)
def copy_thread_post_threads__thread_id__copy_post(
    thread_id: UUID,
) -> Union[Thread, ErrorResponse]:
    """
    Copy Thread
    """
    pass


@router.get(
    "/threads/{thread_id}/history",
    response_model=ThreadsThreadIdHistoryGetResponse,
    responses={"422": {"model": ErrorResponse}},
    tags=["Threads"],
)
def get_thread_history_threads__thread_id__history_get(
    thread_id: UUID, limit: Optional[int] = 10, before: Optional[str] = None
) -> Union[ThreadsThreadIdHistoryGetResponse, ErrorResponse]:
    """
    Get Thread History
    """
    pass


@router.get(
    "/threads/{thread_id}/state",
    response_model=ThreadState,
    responses={"422": {"model": ErrorResponse}},
    tags=["Threads"],
)
def get_latest_thread_state_threads__thread_id__state_get(
    thread_id: UUID,
) -> Union[ThreadState, ErrorResponse]:
    """
    Get Thread State
    """
    pass


@router.post(
    "/threads/{thread_id}/state",
    response_model=ThreadStateUpdateResponse,
    responses={"422": {"model": ErrorResponse}},
    tags=["Threads"],
)
def update_thread_state_threads__thread_id__state_post(
    thread_id: UUID, body: ThreadStateUpdate = ...
) -> Union[ThreadStateUpdateResponse, ErrorResponse]:
    """
    Update Thread State
    """
    pass
